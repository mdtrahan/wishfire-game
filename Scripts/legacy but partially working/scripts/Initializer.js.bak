// Initializer.js
// Pure initialization logic
// Correct Construct 3 JS APIs only

import { ENEMY_DATA } from "./DataAdapter.js";

export function InitializeGame(runtime) {
    const g = runtime.globalVars;

    g.gameInitialized = 1;
    g.boardCreated = 0;
    g.Slots = g.Slots || 3;

    g.cols = g.cols || 6;
    g.rows = g.rows || 4;
    g.cellSize = g.cellSize || 45;
    g.gap = g.gap || 2;
    g.gx = g.gx || 32;
    g.gy = g.gy || 365;

    const grid = runtime.objects.Grid?.getFirstInstance();
    const tapSeq = runtime.objects.TapSeq?.getFirstInstance();
    const heroes = runtime.objects.Heroes.getAllInstances();

    const uiCloseWin = runtime.objects.UI_CloseWin?.getFirstInstance();
    const navCloseButton = runtime.objects.UI_NavCloseButton?.getFirstInstance();
    const navCloseX = runtime.objects.UI_NavCloseX?.getFirstInstance();
    const inputBlocker = runtime.objects.InputBlocker?.getFirstInstance();
    const enemyIDs = runtime.objects.EnemyIDs?.getFirstInstance();
    const enemySprites = runtime.objects.Enemy_Sprite.getAllInstances();
    console.log("[INIT] Enemy sprites: " + enemySprites.length);

    console.log("[INIT] Calling CreateGemBoard NOW...");
    CreateGemBoard(runtime);
    console.log("[INIT] CreateGemBoard FINISHED and returned");

    g.ChainNumber = 0;
    g.ChainMultiplier = 1;
    g.LastMatchColor = -1;
    g.ApplyChainToNextDamage = 0;
    g.ApplyChainToNextHeal = 0;

    const frameActionMap = runtime.objects.FrameActionMap?.getFirstInstance();

    g.TurnPhase = 0;
    const phaseInfo = runtime.objects.txtPhaseInfo?.getFirstInstance();
    if (phaseInfo) {
        phaseInfo.text = "Hero Turn";
    }

    console.log("[INIT] InitializeGame complete");
}

export function CreateGemBoard(runtime) {
    const g = runtime.globalVars;
    g.boardCreated = 1;

    const gemType = runtime.objects.Gem;

    if (!gemType) {
        console.error("[BOARD] ERROR: Gem object type does not exist!");
        return;
    }

    const existingPH = runtime.objects.PH.getAllInstances();
    for (const ph of existingPH) {
        ph.destroy();
    }

    let phCreated = 0;
    for (let c = 0; c < g.cols; c++) {
        for (let r = 0; r < g.rows; r++) {
            const x = Math.floor(g.gx + c * (g.cellSize + g.gap) + g.cellSize / 2) + 0.5;
            const y = Math.floor(g.gy + r * (g.cellSize + g.gap) + g.cellSize / 2) + 0.5;

            const ph = runtime.objects.PH.createInstance("BoardBG", x, y);
            if (ph) {
                ph.width = g.cellSize;
                ph.height = g.cellSize;
                ph.stopAnimation();
                ph.animationFrame = 0;
                phCreated++;
            }
        }
    }

    const existingGems = runtime.objects.Gem.getAllInstances();
    for (const gem of existingGems) {
        gem.destroy();
    }

    let createdCount = 0;

    for (let c = 0; c < g.cols; c++) {
        for (let r = 0; r < g.rows; r++) {
            const x = Math.floor(g.gx + c * (g.cellSize + g.gap) + g.cellSize / 2) + 0.5;
            const y = Math.floor(g.gy + r * (g.cellSize + g.gap) + g.cellSize / 2) + 0.5;

            const gem = runtime.objects.Gem.createInstance("GemBG", x, y);
            if (!gem) {continue;}

            gem.instVars.cellC = c;
            gem.instVars.cellR = r;
            gem.width = g.cellSize;
            gem.height = g.cellSize;
            gem.isVisible = true;

            const xVal = Math.floor(Math.random() * 1000);
            let frameNum;
            if (xVal < 998) {
                frameNum = Math.floor(Math.random() * 6);
            } else if (xVal === 998) {
                frameNum = 6;
            } else {
                frameNum = 7;
            }

            gem.stopAnimation();
            gem.animationFrame = frameNum;
            gem.instVars.elementIndex = frameNum;
            createdCount++;
        }
    }

    console.log("[BOARD] Created " + createdCount + " gems");
}

export function InitializeChainSystem(runtime) {
    const g = runtime.globalVars;
    g.ChainNumber = 0;
    g.ChainMultiplier = 1;
    g.LastMatchColor = -1;
    g.ApplyChainToNextDamage = 0;
    g.ApplyChainToNextHeal = 0;

    const chainTracker = runtime.objects.Chain_Tracker?.getFirstInstance();
    if (chainTracker) {
        chainTracker.text = "";
        chainTracker.isVisible = false;
    }
}

export function SlotX(runtime, slotIndex) {
    const g = runtime.globalVars;
    return (g.SlotStartX || 50) + (slotIndex * (g.SlotWidth || 100));
}

export function SlotY(runtime, slotIndex) {
    const g = runtime.globalVars;
    return g.SlotYPosition || 120;
}

export async function LoadEnemiesComplete(runtime) {
    const g = runtime.globalVars;

    console.log("[ENEMY] Loading enemies from static data...");

    const enemySlots = runtime.objects.EnemySlots?.getFirstInstance();
    console.log("[ENEMY] EnemySlots object:", enemySlots ? "found" : "NOT FOUND");
    console.log("[ENEMY] EnemySlots type:", enemySlots ? enemySlots.constructor.name : "none");
    console.log("[ENEMY] setSize type:", typeof (enemySlots?.setSize));

    if (enemySlots && typeof enemySlots.setSize === "function") {
        console.log("[ENEMY] Initializing EnemySlots with size=" + (g.Slots || 3));
        enemySlots.setSize(g.Slots || 3, 1, 1);
        console.log("[ENEMY] setSize returned, type:", typeof (enemySlots?.setAt));
    } else {
        console.error("[ENEMY] EnemySlots not available or missing setSize");
        return;
    }

    if (g.Slots > 0) {
        console.log("[ENEMY] Starting spawn loop, slots=" + g.Slots);

        for (let s = 0; s < g.Slots; s++) {
            let attempts = 0;
            let spawned = false;

            console.log("[ENEMY] Spawning enemy for slot " + s);

            while (attempts < 10 && !spawned) {
                attempts++;
                const randomIndex = Math.floor(Math.random() * ENEMY_DATA.length);
                const enemyData = ENEMY_DATA[randomIndex];

                console.log("[ENEMY] Attempt " + attempts + ": Picking enemy [" + enemyData.name + "] from array, index=" + randomIndex);

                spawned = await SpawnEnemy(runtime, enemyData, s);

                if (spawned) {
                    console.log("[ENEMY] Spawned " + enemyData.name + " in slot " + s);
                }
            }

            if (!spawned) {
                console.log("[ENEMY] Failed to spawn enemy in slot " + s + " after 10 attempts");
            }
        }
    }

    console.log("[ENEMY] Building turn order...");
    BuildTurnOrder(runtime);

    g.CurrentTurnIndex = 0;
    console.log("[ENEMY] Starting first turn");
}

export function PickNextEnemyID(runtime) {
    const enemyArray = runtime.objects.EnemyArray?.getFirstInstance();
    if (!enemyArray || enemyArray.height <= 1) {
        return "";
    }

    const idx = Math.floor(runtime.random(1, enemyArray.height));
    const name = enemyArray.getAt(0, idx, 0);

    return name || "";
}

export function SlotX(runtime, slotIndex) {
    const g = runtime.globalVars;
    return (g.SlotStartX || 50) + (slotIndex * (g.SlotWidth || 100));
}

export function SlotY(runtime, slotIndex) {
    const g = runtime.globalVars;
    return g.SlotYPosition || 120;
}

export async function SpawnEnemy(runtime, enemyData, slotIndex) {
    const g = runtime.globalVars;

    console.log("[ENEMY] SpawnEnemy() called for: " + enemyData.name + " in slot " + slotIndex);

    const x = SlotX(runtime, slotIndex);
    const y = SlotY(runtime, slotIndex);

    const enemy = runtime.objects.Enemy_Sprite.createInstance("Enemies", x, y);

    if (!enemy) {
        console.log("[ENEMY] Failed to create sprite for: " + enemyData.name);
        return false;
    }

    enemy.instVars.HP = enemyData.HP;
    enemy.instVars.maxHP = enemyData.HP;
    enemy.instVars.ATK = enemyData.ATK;
    enemy.instVars.DEF = enemyData.DEF;
    enemy.instVars.MAG = enemyData.MAG;
    enemy.instVars.RES = enemyData.RES;
    enemy.instVars.SPD = enemyData.SPD;
    enemy.instVars.name = enemyData.name;
    enemy.instVars.IsSelected = 0;
    enemy.instVars.IsBlocked = 0;
    enemy.instVars.action = "";
    enemy.instVars.hp_red = enemyData.hp_red;
    enemy.instVars.hp_blue = enemyData.hp_blue;
    enemy.instVars.hp_green = enemyData.hp_green;

    enemy.stopAnimation();

    const enemySlots = runtime.objects.EnemySlots?.getFirstInstance();
    if (enemySlots && typeof enemySlots.setAt === "function") {
        enemySlots.setAt(slotIndex, 0, 0, enemy.uid);
    }

    console.log("[ENEMY] Spawned enemy: " + enemyData.name + " at slot " + slotIndex);

    return true;
}

export function DebugTest(runtime) {
    const g = runtime.globalVars;
    const gems = runtime.objects.Gem.getAllInstances();

    let info = "=== GEM DEBUG ===\n";
    info += "boardCreated: " + g.boardCreated + "\n";
    info += "gameInitialized: " + g.gameInitialized + "\n";
    info += "Total gems: " + gems.length + "\n";
    info += "gx: " + g.gx + ", gy: " + g.gy + "\n";
    info += "cols: " + g.cols + ", rows: " + g.rows + "\n";
    info += "cellSize: " + g.cellSize + ", gap: " + g.gap + "\n\n";

    for (let i = 0; i < Math.min(5, gems.length); i++) {
        const gem = gems[i];
        info += "Gem " + i + ": frame=" + gem.animationFrame + ", visible=" + gem.isVisible + ", x=" + Math.round(gem.x) + ", y=" + Math.round(gem.y) + "\n";
    }

    if (gems.length > 5) {
        info += "... and " + (gems.length - 5) + " more\n";
    }

    alert(info);
}

export function SlotX(runtime, slotIndex) {
    const g = runtime.globalVars;
    return (g.SlotStartX || 50) + (slotIndex * (g.SlotWidth || 100));
}

export function SlotY(runtime, slotIndex) {
    const g = runtime.globalVars;
    return g.SlotYPosition || 120;
}
