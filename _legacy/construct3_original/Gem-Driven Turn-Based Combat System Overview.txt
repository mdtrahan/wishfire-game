### Elevator pitch

This is a **turn-based, match-3â€“driven party combat RPG** where gem matches are not abstract points but **explicit combat commands**. Players select up to three gems per turn to lock in attacks, buffs, heals, or resources, then resolve those actions through a visible turn order shared by heroes and enemies. Color and chain logic turn the board into a tactical input surface rather than a puzzle for its own sake.

### One-paragraph detailed description (scaffolding-oriented)

The game runs on a **strict state machine** that alternates between player input, resolution, and enemy turns, with the gem board acting as a **command encoder**: selecting three matching gems of a color queues a specific action (single-target attack, AOE effect, defensive buff, heal, energy, or gold), while mismatches are rejected and reset. Combat is party-based, with heroes and enemies sharing a computed initiative order stored in arrays and advanced deterministically. Skills are modular functions invoked by dispatchers (`ResolveGemAction`, `ExecuteSkill`), buffs are global party states with caps and turn counters, and UI layers (selectors, overlays, chain indicators) are purely reactive to global variables like `TurnPhase`, `IsAOEMatch`, and chain flags. Chains modify the *next* damage or heal rather than retroactively changing actions, reinforcing predictability. Architecturally, the system cleanly separates **input capture (UI_Logic)**, **game state & flow (Main / CombatLogic)**, **pure mechanics (Function_Bank / Skill Sheet)**, making it well-suited to migration from Construct events to JavaScript by treating JS modules as authoritative systems that the UI merely reflects.
